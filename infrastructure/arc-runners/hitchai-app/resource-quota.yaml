apiVersion: v1
kind: ResourceQuota
metadata:
  name: arc-runners-quota
  namespace: arc-runners
spec:
  hard:
    # Lightweight Runner Strategy: 12 concurrent runners with reduced limits
    # Key insight: Reduced per-runner limits (4Gi vs 12Gi) enable higher parallelism
    #              limits.memory caps total burst to 50Gi (39% of 128GB cluster)

    # CPU quotas with overcommit:
    # - DinD pods: 12 × (10m init + 100m dind + 100m runner) = 12 × 210m = 2.52 cores requests
    # - Total: ~3 cores requests → 12 runners guaranteed schedulable
    requests.cpu: "3"
    # Limits allow bursting: 12 × (100m init + 500m dind + 1 core runner) = 12 × 1.6 cores = 19.2 cores potential
    limits.cpu: "20"

    # Memory quotas with overcommit (LIGHTWEIGHT CONFIGURATION):
    # - DinD pods: 12 × (64Mi init + 128Mi dind + 256Mi runner) = 12 × 448Mi = 5.25Gi requests
    #             12 × (128Mi init + 2Gi dind + 4Gi runner) = 12 × 6.128Gi = 73.5Gi limits potential
    # Total requests: 5.25Gi → 12 runners ALWAYS fit
    # Total limits: 73.5Gi potential → quota caps at 50Gi ✅
    # Actual enforcement: Only ~8 runners can burst simultaneously to full limits
    requests.memory: "6Gi"   # 5.25Gi used, 0.75Gi headroom
    limits.memory: "50Gi"    # HARD CAP - 39% of 128GB cluster (allows 78GB for apps)

    # Pod count limit (safety valve for runaway scaling)
    count/pods: "20"  # 12 max DinD runners + 8 buffer for rolling updates/cleanup

# How lightweight runners work:
#
# Per-pod resources:
#   Init:   128Mi limit
#   DinD:   2Gi limit (reduced from 6Gi)
#   Runner: 4Gi limit (reduced from 12Gi)
#   Total:  ~6.128Gi per pod
#
# Math:
#   50Gi quota ÷ 6.128Gi = 8.16 pods can burst to full limits simultaneously
#   Remaining 4 pods will use actual RAM (typically 1-2Gi each)
#
# Example scenario 1 (12 light jobs):
#   12 pods × 1.5Gi actual = 18Gi total
#   All 12 runners active, plenty of headroom
#
# Example scenario 2 (Mixed workload):
#   8 light jobs × 1.5Gi = 12Gi
#   4 heavier jobs × 4Gi = 16Gi
#   Total: 28Gi (well under 50Gi cap)
#
# Example scenario 3 (Heavy burst):
#   8 pods burst to 6Gi each = 48Gi
#   Quota blocks 9th pod from bursting
#   Actual: 8 heavy + 4 light = typical realistic load
#
# Benefits:
# - 12 concurrent jobs vs 4 (3× parallelism increase)
# - Lower per-job limits sufficient for most builds
# - Registry cache reduces Docker layer downloads
# - Statistical multiplexing: not all jobs peak simultaneously
# - Single-node cluster: 50Gi / 128Gi = 39% memory budget for runners (78GB for apps)
#
# Trade-offs:
# - Cannot run 12 memory-intensive builds simultaneously (only ~8 can max out)
# - Very heavy builds (>4Gi) may OOM, but these are rare
# - Most CI/CD workflows fit comfortably in 2-3Gi actual usage
